input {
        tcp {
                port => 5000
        }
}

filter{
    grok{
        match => { "message" => "%{WORD:application}%{SPACE}%{WORD:logtype}%{SPACE}(%{IP:victim:ip}%{SPACE})?%{GREEDYDATA:logdata}"}
    }
    # Lookup the team name based on IP
    translate{
        field => "[victim]"
        destination => "[team]"
        dictionary_path => "/etc/logstash/conf.d/hosts_team.json"
        fallback => "redteam"
        regex => true
        #add_tag => ["%{team}"]
    }

    # Lookup the OS based on the IP
    translate{
        field => "[victim]"
        regex => true
        destination => "[os]"
        dictionary_path => "/etc/logstash/conf.d/hosts_os.json"
    }

    # If its redteam or unknown, we dont have a victim IP
    if [team] !~ /[T|t]eam\d+/ {
        mutate{
            rename => ["victim", "ip"]
        }
    }

    # Pull the credentials from the log
    if [logtype] == "CREDENTIAL"{
        grok{
            match => {logdata => "%{WORD:credtype}(\s+|:)%{WORD:username}(\s+|:)%{GREEDYDATA:password}"}
        }
    }

    # Pull /etc/hosts data
    if [logtype] =~ "HOSTS.*"{
       grok{
               match => {logdata => "%{IP:host_ip}%{SPACE}%{GREEDYDATA:host_name}"}
       }
    }

    # Figure out if its a beacon or an exploit
    if [logtype] == "BOXACCESS"{
        if [logdata] =~ /.*[E|e]xploit.*/ {
            mutate{
                add_field => {"accesstype" => "exploit"}
            }
        }
        if [logdata] =~ /.*([B|b]eacon|[C|c]allback).*/{
            mutate{
                add_field => {"accesstype" => "beacon"}
            }
        }
    }
}


# Use this to debug the grok filters
#output {
#    file {
#        path => "/tmp/json_output.txt"
#        codec => "json"
#    }
#}
output {
	elasticsearch {
		hosts => "elasticsearch:9200"
	}
}
